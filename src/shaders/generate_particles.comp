layout(constant_id = 0) const  uint max_emitters = 4;
layout(constant_id = 1) const  uint max_particles = 256;

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

struct ParticleEmitterInfo{
	vec4 pos;
	float timer;
	float freq;
};

struct ParticleInfo{
	vec4 pos;
	vec4 dir;
	float lifetime;
	float time;
};


struct MKey{
	vec4 dir;
	float time;
};

layout (set = 0, binding = 0) buffer Emitter{
	ParticleEmitterInfo emitters[max_emitters];
	uint emitter_use[max_emitters];
	uint draw_count;
	float time;

	uint keys_count;
	MKey keys_array[1024 * 8];
} emitter;

layout (set = 0, binding = 1) buffer Particle{
	ParticleInfo particles[max_particles];
} particle;


layout (set = 1, binding = 0) buffer Vert{
	vec4 verts[max_particles * 4];
} vert;


layout (set = 1, binding = 1) buffer Ind{
	uint indices[max_particles * 6];
} ind;

layout(push_constant) uniform PushConsts{
	vec3 camera_side;
	vec3 camera_up;
} pushconst;




float Random(vec2 co){
	co += vec2(0.2,-0.7);
	return (fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453) - 0.5f) * 2.0f;
}

vec3 RandomVec3(vec2 co){
	return vec3(Random(co),Random(co.yx * 3.142),Random(co.yx * 0.142));
}


//simulates collision of a sphere radius 1 and centered at the origin
vec3 SphereCollision(vec3 pos,vec3 dir){
	vec3 s_pos = vec3(0,0,0);
	float r = 1.0f;
	vec3 d = pos - s_pos;

	if(length(d) <= r){
		float k = length(dir);
		return reflect(normalize(dir),normalize(d)) * k;
	}

	return dir;
}

vec3 LineSphereIntersect(vec3 pos,vec3 dir){

	vec3 s_pos = vec3(0,0,0);
	float r = 1.0f;

	vec3 line_to_sphere = s_pos - pos;

	float a = dot(dir,dir);
	float b = -2.0f * dot(dir,line_to_sphere);
	float c = dot(line_to_sphere,line_to_sphere) - (r * r);

	float discriminant = (b * b) - (4.0f * a * c);

	if(discriminant < 0.0f){
		return pos;
	}

	float root = sqrt(discriminant);

	float t0 = ((-1.0f * b) + root) / (2.0f * a);
	float t1 = ((-1.0f * b) - root) / (2.0f * a);

	float abs_t0 = abs(t0);
	float abs_t1 = abs(t1);

	float err = 0.0001f;

	return abs_t0 < abs_t1 ? (pos + (dir * t0)) : (pos + (dir * t1));
}

vec3 IsParticleOnSphere(vec3 pos,vec3 dir){
	vec3 s_pos = vec3(0,0,0);
	float r = 1.0f;

	vec3 p = length(s_pos - pos) <= r ? LineSphereIntersect(pos,dir) : pos;

	return p;
}

vec3 FunctionDir(float time){

	vec3 dir = vec3(0,0,0);

	for(uint i = 0; i < emitter.keys_count; i++){
		if(time < emitter.keys_array[i].time){
			dir = vec3(emitter.keys_array[i].dir.xyz) * 20.0f;
			break;
		}
	}

	return dir;
}


void main(){
	uint particle_index = gl_GlobalInvocationID.x;
	uint emitter_index = gl_LocalInvocationID.x;

	if(particle.particles[particle_index].time < particle.particles[particle_index].lifetime){

		{
			vec3 dir = particle.particles[particle_index].dir.xyz;
			vec3 pos = particle.particles[particle_index].pos.xyz;
			vec3 f_dir = FunctionDir(particle.particles[particle_index].time);

			//pos = IsParticleOnSphere(pos,dir);
			//dir = SphereCollision(pos,dir);

			particle.particles[particle_index].dir = vec4(dir,0);
			particle.particles[particle_index].pos = vec4(f_dir + pos + dir * emitter.time * 0.01,1);
			particle.particles[particle_index].time += emitter.time;
		}



		uint count = 0;
		uint actual = 0;

		do{
			count = emitter.draw_count;
			actual = atomicCompSwap(emitter.draw_count,count, count + 1);
		}while(count != actual);

		uint vert_index = count * 4;
		uint ind_index = count * 6;
		vec4 pos = particle.particles[particle_index].pos;

		vert.verts[vert_index] = pos;
		vert.verts[vert_index + 1] = pos + vec4(pushconst.camera_up,0);
		vert.verts[vert_index + 2] = pos + vec4(pushconst.camera_side,0) + vec4(pushconst.camera_up,0);
		vert.verts[vert_index + 3] = pos + vec4(pushconst.camera_side,0);

		ind.indices[ind_index] = vert_index;
		ind.indices[ind_index + 1] = vert_index + 1;
		ind.indices[ind_index + 2] = vert_index + 2;
		ind.indices[ind_index + 3] = vert_index + 2;
		ind.indices[ind_index + 4] = vert_index + 3;
		ind.indices[ind_index + 5] = vert_index;
	}

	else if(emitter.emitter_use[emitter_index] == 1){

		if(emitter.emitters[emitter_index].timer >= emitter.emitters[emitter_index].freq){
			vec3 pos = 
				emitter.emitters[emitter_index].pos.xyz;
			vec3 dir = RandomVec3(vec2(gl_LocalInvocationID.x,gl_GlobalInvocationID.x));
			float lifetime = abs(Random(vec2(pos.x,dir.z))) * 2000.0f;

			particle.particles[particle_index].pos = vec4(pos.xyz,1);
			particle.particles[particle_index].dir = vec4(0,1,0,0);
			//particle.particles[particle_index].dir = vec4(dir.xyz,0);
			//particle.particles[particle_index].dir = normalize(vec4(0,5,0,0) + vec4(dir.xyz,0));
			particle.particles[particle_index].lifetime = lifetime;
			particle.particles[particle_index].time = 0.0f;
			emitter.emitters[emitter_index].timer = 0;
		}

	}


}
