layout(constant_id = 0) const  uint max_emitters = 4;
layout(constant_id = 1) const  uint max_particles = 256;

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

struct ParticleEmitterInfo{
	vec4 pos;
	float timer;
	float freq;
};

struct ParticleInfo{
	vec4 pos;
	vec4 dir;
	float lifetime;
};

layout (set = 0, binding = 0) buffer Emitter{
	ParticleEmitterInfo emitters[max_emitters];
	uint emitter_use[max_emitters];
	uint particle_count;
	//TODO: we need a separate val for the draw buffer
	float time;
} emitter;

layout (set = 0, binding = 1) buffer Particle{
	ParticleInfo particles[max_particles];
} particle;


layout (set = 1, binding = 0) buffer Vert{
	vec3 verts[max_particles * 4];
} vert;


layout (set = 1, binding = 1) buffer Ind{
	uint indices[max_particles * 6];
} ind;






float Random(vec2 co){
	return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 RandomVec3(vec2 co){
	return vec3(Random(co),Random(co.yx * 3.142),Random(co.yx * 0.142));
}




void main(){
	uint particle_index = gl_GlobalInvocationID.x;
	uint emitter_index = gl_LocalInvocationID.x;

	if(particle.particles[particle_index].lifetime > 0){
		particle.particles[particle_index].pos += particle.particles[particle_index].dir;
		//particle.particles[particle_index].lifetime -= emitter.time;

		uint count = emitter.particle_count;
		uint actual = atomicCompSwap(emitter.particle_count,count, count + 1);

		if(count == actual){
			uint vert_index = count * 4;
			uint ind_index = count * 6;
			vec3 pos = particle.particles[particle_index].pos.xyz;

			vert.verts[vert_index] = pos;
			vert.verts[vert_index + 1] = pos + vec3(0,1,0);
			vert.verts[vert_index + 2] = pos + vec3(1,1,0);
			vert.verts[vert_index + 3] = pos + vec3(1,0,0);

			ind.indices[ind_index] = vert_index;
			ind.indices[ind_index + 1] = vert_index + 1;
			ind.indices[ind_index + 2] = vert_index + 2;
			ind.indices[ind_index + 3] = vert_index + 2;
			ind.indices[ind_index + 4] = vert_index + 3;
			ind.indices[ind_index + 5] = vert_index;
		}
	}

	else{
				vec3 pos = 
					emitter.emitters[emitter_index].pos.xyz + RandomVec3(vec2(gl_GlobalInvocationID.x,gl_LocalInvocationID.x));
				vec3 dir = RandomVec3(vec2(gl_LocalInvocationID.x,gl_GlobalInvocationID.x));
				float lifetime = abs(Random(vec2(pos.x,dir.z)));

				particle.particles[particle_index].pos = vec4(pos.xyz,1);
				particle.particles[particle_index].dir = vec4(dir.xyz,0);
				particle.particles[particle_index].lifetime = 1.0f;
				emitter.emitters[emitter_index].timer = 0;
	}

#if 0

	else if(emitter.emitter_use[emitter_index] == 0){

		uint emitter_use = emitter.emitter_use[emitter_index];
		uint actual = atomicCompSwap(emitter.emitter_use[emitter_index],emitter_use, emitter_use + 1);

#if 0

		float timer = emitter.emitters[emitter_index].timer;
		float freq = emitter.emitters[emitter_index].timer;

		if(emitter_use == actual){
			if(timer > freq){
				vec3 pos = emitter.emitters[emitter_index].pos + RandomVec3(vec2(gl_GlobalInvocationID.x,gl_LocalInvocationID.x));
				vec3 dir = RandomVec3(vec2(gl_LocalInvocationID.x,gl_GlobalInvocationID.x));
				float lifetime = abs(Random(vec2(pos.x,dir.z)));

				particle.particles[particle_index].pos = pos;
				particle.particles[particle_index].dir = dir;
				particle.particles[particle_index].lifetime = lifetime;
				emitter.emitters[emitter_index].timer = 0;
			}
			emitter.emitters[emitter_index].timer += emitter.time;
		}

#endif


	}
#endif

}
